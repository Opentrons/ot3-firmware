#ifndef COMMON_CORE_VERSION_H_
#define COMMON_CORE_VERSION_H_
#include <stdint.h> // uint32_t
#include <stdlib.h> // size_t
#ifdef __cplusplus
extern "C" {
#endif  // __cplusplus

/**
 * Interface to code-generated version data. This is generated by cmake.
 * It will be regenerated on each build, but because its data is in a .c
 * file it shouldn't incur much other than a relink.
 *
 * */
// The size of a git-describe short sha with a nul terminator to avoid
// fooling anybody
#define VERSION_SHORTSHA_SIZE 8

// Flags that can apply to a build:
enum version_flags {
   // Build was from a fully committed working tree (e.g. git describe does
   // not say -dirty)
   VERSION_BUILD_IS_EXACT_COMMIT=0x1,
   // Build was from a commit that is pointed directly to by a version tag
   VERSION_BUILD_IS_EXACT_VERSION=0x2,
   // Build was from automated builds and likely distributed, not a dev
   VERSION_BUILD_IS_FROM_CI=0x4
};
struct version {
    uint32_t version;
    uint32_t flags;
    char sha[VERSION_SHORTSHA_SIZE];
};

const struct version* version_get();

// Do not base the size of messages that include this data on the size of
// this struct, since it is not packed. Instead, use revision_size(), and if
// you update this struct make sure to update that value.
struct  revision {
    char primary;
    char secondary;
    char tertiary[2];
};

// What the size of the revision struct would be if it was packed.
size_t revision_size();

const struct revision* revision_get();

#ifdef __cplusplus
} // extern "C"
#endif // __cplusplus
#endif // defined COMMON_CORE_VERSION_H
